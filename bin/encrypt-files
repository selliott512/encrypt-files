#!/bin/bash

# Encrypt files one at time using a combination of a secret password and the
# file's relative path as the password.

# Semi-strict mode.

set -eo pipefail
# For bash 4.3 and earlier empty arrays fail with "set -u".
if [[ $(( 10*${BASH_VERSINFO[0]} + ${BASH_VERSINFO[1]} )) -ge 44 ]]
then
    set -u
fi
IFS=$' \t\n'

# Globals

bname="${0##*/}"
tmp_dir="/tmp/$bname.$$"

conf_file="/etc/$bname.conf"
hash_file="$tmp_dir/hash"
hash_actual_file="$tmp_dir/hash-actual"
hash_expected_file="$tmp_dir/hash-expected"
hdr_file="$tmp_dir/hash"
pass_file="$tmp_dir/pass"
src_list_file="$tmp_dir/src-files"

# Required and optional configuration parameters.
config_req_ar=(pass)
config_opt_ar=()

# Used to parse command line options.
opt_getopts="dkruv"

# The encryption algorithm to use.
# TODO: Consider different algorithms for different files. For example, for
# large files that have small changes "aes-256-ofb" would be more efficient
# because only bits modified in the source would be modified in the
# destination. However, an attacker would be able to gain more insight into the
# files by XORing multiple versions of the encrypted file.
crypto_alg="aes-256-cbc"

# Functions

function cleanup()
{
    if [[ -n ${opt[k]} ]]
    then
        echo "Keeping temporary directory \"$tmp_dir\"."
        return
    fi

    if [[ -d $tmp_dir ]]
    then
        if [[ -f "$pass_file" ]]
        then
            shred -u "$pass_file"
        fi
        rm -f "$tmp_dir"/*
        rmdir "$tmp_dir"
    else
        echo "Missing temporary directory \"$tmp_dir\"." 1>&2
        exit 1
    fi
}

# Read the configuraiton file $conf_file.
function config_read()
{
    if [[ ! -r $conf_file ]]
    then
        echo "Configuration file \"$conf_file\" either does not exist, or is \
not readable." 1>&2
        exit 1
    fi

    # Convert the required and and optional keys to associative arrays, which
    # are like sets.

    unset req_as
    declare -A req_as
    for key in "${config_req_ar[@]}"
    do
        req_as[$key]=t
    done

    unset opt_as
    declare -A opt_as
    for key in "${config_opt_ar[@]}"
    do
        opt_as[$key]=t
    done

    # The global associative array produced by this function.
    unset conf
    declare -gA conf

    # Read the config file.
    while read line
    do
        key="${line%%=*}"
        key="${key#"${key%%[![:space:]]*}"}" # Leading whitespace.
        key="${key%"${key##*[![:space:]]}"}" # Trailing whitespace   
        if [[ (-z $key) || ($key == \#*) ]]
        then
            # A comment or blank line.
            continue
        fi
        key=$(tr -dc "[0-9A-Za-z]" <<< "$key")

        value="${line#*=}"
        value="${value#"${value%%[![:space:]]*}"}" # Leading whitespace.
        value="${value%"${value##*[![:space:]]}"}" # Trailing whitespace.

        if [[ (-z ${req_as[$key]}) && (-z ${opt_as[$key]}) ]]
        then
            echo "Key \"$key\" in configuration file \"$conf_file\" is not \
allowed." 1>&2
            exit 1
        fi
        conf[$key]="$value"
    done < "$conf_file"
    
    # Determine the required keys that are missing.
    missing_ar=()
    for key in "${!req_as[@]}"
    do
        if [[ -z ${conf[$key]} ]]
        then
            missing_ar+=($key)
        fi
    done
    if [[ -n $missing_ar ]]
    then
        echo "Configuration file \"$conf_file\" is missing required keys: \
${missing_ar[@]}" 1>&2
        exit 1
    fi
}

# Parse command line options.
function opt_parse()
{
    if [[ $opt_getopts == :* ]]
    then
        echo "\$opt_getots\"=$opt_getopts should not start with \":\"." 1>&2
        exit 1
    fi

    if [[ $opt_getopts == *::* ]]
    then
        echo "\$opt_getots\"=$opt_getopts should have more than one \":\" in \
a row." 1>&2
        exit 1
    fi

    # The global option array.
    declare -gA opt

    # Make sure all possible options are set so $opt can be referenced.
    for (( i=0; i<${#opt_getopts}; i++ ))
    do
        o="${opt_getopts:$i:1}"
        if [[ $o == : ]]
        then
            continue
        fi
        opt["$o"]=""
    done

    while getopts "$opt_getopts" o
    do
        if [[ $o == "?" ]]
        then
            # An option that's not in $opt_getopts.
            exec 1>&2
            usage
            exit 1
        else
            if [[ -v OPTARG ]]
            then
                opt["$o"]="$OPTARG"
            else
                opt["$o"]=t
            fi
        fi
    done
}

function usage()
{
    echo "Usage: $bname  [-d] [-k] [-r] [-v] source dest" 1>&2
    echo "    -d   Decrypt instead of encrypt." 1>&2
    echo "    -k   Keep temporary files." 1>&2
    echo "    -r   Relative paths (like rsync)." 1>&2
    echo "    -v   Verbose." 1>&2
    echo "    src  The source directory or file. Prefix with \"@\" for file \
list." 1>&2
    echo "    dst  The destination directory." 1>&2
}

# Main entry

# Read the config file.
config_read

if [[ ${conf[pass]} == iO0p9ivpEiG64ssEwWDfEusJB2mmHXhBMBWXYGT4c52pG ]]
then
    echo "WARNING: You MUST CHANGE the default password in \"$conf_file\" in \
order to be secure." 1>&2
fi

opt_parse "$@"

# So that only positional arguments, if any, remain.
shift $((OPTIND - 1))

if [[ $# -lt 2 ]]
then
    usage
    exit 1
fi

src="$1"
# Get rid of the tailing slash, if any.
if [[ $src == */ ]]
then
    src="${src:0:-1}"
fi

dst="$2"
# Get rid of the tailing slash, if any.
if [[ $dst == */ ]]
then
    dst="${dst:0:-1}"
fi

if [[ (-n ${opt[d]}) && (-n ${opt[r]}) ]]
then
    echo "Options -d and -r are not compatible." 1>&2
    exit 1
fi

if [[ $src == @* ]]
then
    # "src" is actually a list of source files each of which is a source top.
    # In this case there is no prefix common to all source directories.
    src_fname="${src:1}"
    src_tops="$(<$src_fname)"
    src_prefix_len=0
else
    # There is a single source top directory, which is a common prefix to all
    # source directories found.
    src_tops="$src"
    src_prefix_len="${#src}"
fi

# Create a temporary directory
if ! mkdir -m 700 "$tmp_dir"
then
    echo "Could not create temporary directory \"$tmp_dir\"." 2>&2
    exit 1
fi
trap cleanup EXIT

# Incremented for each error found.
errors=0

if ! find $src_tops > "$src_list_file"
then
    echo "One or more error finding \"$src_tops\"." 1>&2
    let errors++
fi

if [[ -n ${opt[d]} ]]
then
    action="dec"
else
    action="enc"
fi

if [[ -n ${opt[v]} ]]
then
    echo "Action                : $action"
    echo "Source tops           :" $src_tops
    echo "Destination directory :" $dst
fi

while read src_file
do
    if [[ $src_file != /* ]]
    then
        echo "Source file \"$src_file\" does not start with \"/\". \
Ignoring." 1>&2
        let errors++
    fi

    # Get rid of the tailing slash, if any.
    if [[ $src_file == */ ]]
    then
        src_file="${src_file:0:-1}"
    fi

    if [[ -n ${opt[r]} ]]
    then
        # Remove leading slash.
        src_file_rel="${src_file:1}"
    else
        # Remove the common source prefix and then +1 for the leading slash.
        src_file_rel="${src_file:$src_prefix_len+1}"
    fi

    # Use the relative path of the file as part of the password.
    # echo "${conf[pass]}|$src_file_rel" > "$pass_file"
    echo "${conf[pass]}|$src_file_rel" > "$pass_file"

    # Get rid of the tailing slash, if any.
    dst_file="$dst/$src_file_rel"
    if [[ $dst_file == */ ]]
    then
        dst_file="${dst_file:0:-1}"
    fi

    if [[ -d $src_file ]]
    then
        if [[ -n ${opt[v]} ]]
        then
            echo "dir \"$dst_file\""
        fi
        if ! mkdir -p "$dst_file"
        then
            echo "Could not make directory \"$dst_dir\"." 1>&2
            let errors++
        fi
    elif [[ -f $src_file ]]
    then
        src_base="${src_file##*/}"
        if [[ (-n ${opt[u]}) && !($src_file -nt $dst_file) ]]
        then
            if [[ -n ${opt[v]} ]]
            then
                echo "old \"$src_file\""
            fi
            continue
        fi
        if [[ -n ${opt[v]} ]]
        then
            echo "$action \"$src_file\" -> \"$dst_file\""
        fi

        # xxdebug figure it out
        no_salt=t

        if [[ -n ${opt[d]} ]]
        then
            # Decrypt
            hdr=$(head -c 32 "$src_file")
            read -ra hdr_ar <<< "$hdr"
        
            # The first two tokens should be fixed.
            if [[ ${#hdr_ar[@]} -lt 2 ]]
            then
                echo "Invalid header \"$hdr\" for source file \
\"$src_file\"." 1>&2
                let errors++
                continue
            fi
            if [[ ${hdr_ar[0]} != efs ]]
            then
                echo "Unknown file type \"${hdr_ar[0]}\" in header \"$hdr\" \
for source file \"$src_file\"." 1>&2
                let errors++
                continue
            fi
            if [[ ${hdr_ar[1]} != 1 ]]
            then
                echo "Unknown version \"${hdr_ar[1]}\" in header \"$hdr\" for \
source file \"$src_file\"." 1>&2
                let errors++
                continue
            fi
            calg="${hdr_ar[2]}"

            # Process the header options.
            do_nosalt=""
            for (( i=3; i<${#hdr_ar[@]}; i++ ))
            do
                hopt="${hdr_ar[i]}"
                case "$hopt" in
                    ns)
                        do_nosalt="t"
                        ;;
                    *)
                        echo "Unknown header option \"$hopt\". Ignoring." 1>&2
                        let errors++
                        ;;
                esac
            done

            if ! tail -c +33 "$src_file" | openssl "$calg" -d \
                ${do_nosalt:+-nosalt} -pass file:"$pass_file" -out "$dst_file"
            then
                echo "Could not decrypt \"$src_file\" to \"$dst_file\"." 1>&2
                rm -f "$dst_file"
                let errors++
                continue
            fi
            tail -c 32 "$dst_file" > "$hash_expected_file"
            truncate -cs -32 "$dst_file"
            openssl dgst -sha256 -binary -out "$hash_actual_file" "$dst_file"
            if ! diff -q "$hash_actual_file" "$hash_expected_file" &> /dev/null
            then
                echo "For \"$dst_file\" the hash did not match." 1>&2
                let errors++
            fi
        else
            # Encrypt
            printf "%-31s\n" "efs 1 $crypto_alg ${no_salt+ns}" > "$dst_file"
            openssl dgst -sha256 -binary -out "$hash_actual_file" "$src_file"
            if ! cat "$src_file" "$hash_actual_file" | openssl "$crypto_alg" -nosalt \
                -pass file:"$pass_file" >> "$dst_file"
            then
                echo "Could not encrypt \"$src_file\" to \"$dst_file\"." 1>&2
                rm -f "$dst_file"
                let errors++
            fi
        fi
    else
        echo "Source file \"$src_file\" is not a file or directory. \
Ignoring." 1>&2
        let errors++
    fi
done < "$src_list_file"

if [[ $errors -gt 0 ]]
then
    echo "$errors errors."
    exit 1
else
    if [[ -n ${opt[v]} ]]
    then
      echo "Success."
    fi
    exit 0
fi
